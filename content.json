{"pages":[],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2020/05/17/hello-world/"},{"title":"hello, Hexo!","text":"test1code here hello, Hexo!","link":"/2020/05/17/hello-Hexo/"},{"title":"制作五子棋AI","text":"关于本文：这是本蒟蒻的第一篇博客，介绍了我5升6暑假用一周时间做的作品 语言： Html5， JavaScript 成品：五子棋AI 正文：摘要:阿尔法狗对战柯洁围棋大赛很热门，那只是人工智能中的一个方向，展示了机器能代替人做某些事情。而围棋是很讲究智力的游戏，所以实现起来也是很难的，我用JS写了一个小程序——五子棋，五子棋相对来讲简单很多。 关键词：人工智能；网页编程；HTML5/JavaScript； 制作背景：现在，人工智能技术突飞猛进，许多职业已被机器取代，那么怎样用简单的算法实现五子棋ai呢？ 制作材料：电脑 设计思路： 棋盘的实现： 通过循环画直线 棋子的实现: 画出你想要的棋子，渐变填充颜色，封装成一个函数供调用。 落子的实现: 用数组存放每一个落子点，满足条件就落下对应的子 赢法数组: 用一个二维的数组记录五子棋的所有赢法。每种赢法都有一个值，值达到5就结束游戏。 确定计算机落子点: 这是难点，我们通过为某种赢法附一个权值，权值最大的就是落子价值最大的。 实现计算机落子: 通过上一步计算机找到了权值最大的落子坐标后，我们就可以实现落子了。 制作过程：第一步：写H5框架：1234567891011121314&lt;!doctype html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;Wu Zi Qi--AI&lt;/title&gt; &lt;style type=\"text/css\"&gt; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;script type=\"text/javascript\"&gt; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 第二步：本程序主要使用canvas检测鼠标点击返回值来进行落子,创建canvas对象： 12document.body.innerHTML = '&lt;canvas id=\"chess\" width=\"450\" height=\"450\"&gt; &lt;/canvas&gt;';var chess = document.getElementById('chess'); 第三步：创建赢法数组，统计数组等 123456//赢法数组,用来统计所有的赢法var wins = [];var count = 0;//赢法统计数组，用来统计var myWin = [];var computerWin = []; 第四步：创建并初始化数组显示棋盘 1234567var chessBoard = [];//数组显示棋盘 for (var i = 0; i &lt; 15; i++) { chessBoard[i] = []; for (var j = 0; j &lt; 15; j++) { chessBoard[i][j] = 0; } 第五步：画棋盘 123456789101112var context = chess.getContext('2d');//画棋盘 for (var i = 0; i &lt; 15; i++) { context.strokeStyle = '#00000';//设置颜色 context.beginPath(); context.moveTo(15, 15 + i * 30);//移动 context.lineTo(435, 15 + i * 30);//绘画 context.moveTo(15 + i * 30, 15);//移动 context.lineTo(15 + i * 30, 435);//绘画 context.stroke(); } 第六步：对赢法数组进行初始化和赋值 1234567891011//初始化赢法数组同初始化显示棋盘数组，省略 //横向 for (var i = 0; i &lt; 15; i++) { for (var j = 0; j &lt; 11; j++) { for (var k = 0; k &lt; 5; k++) { wins[i][j+k][count] = true; } count++; } }//纵向，左斜和右斜以此类推 第七步：初始化玩家和ai数组（略 第八步：画棋子，为了使棋子更加逼真，可以在棋子的脚上加一点渐变色，比如黑色棋子的右上角有白色渐变，从而模仿真实棋子反光（图一）。同时获取鼠标点击的位置，进行落子。 最后检查玩家获胜（即五子相连） 12345678910111213141516171819202122232425262728293031323334//画棋子 chess.onclick = function(e) {//鼠标点击容差再30以内（只要点击范围在以交叉点为中心的30*30的正方形状内，都算该交叉点） var i = Math.floor(e.offsetX / 30); var j = Math.floor(e.offsetY / 30); if (chessBoard[i][j] != 0) { return; } context.beginPath(); context.arc(15 + i * 30, 15 + j * 30, 13, 0, 2 * Math.PI); var grd = context.createRadialGradient(15 + i * 30, 15 + j * 30, 13, 15 + i * 30 + 2, 15 + j * 30 - 2, 0); grd.addColorStop(0, 'black'); grd.addColorStop(1, 'white'); context.fillStyle = grd; context.fill(); context.stroke(); chessBoard[i][j] = 1; //检查玩家获胜 for (var k = 0; k &lt; count; k++) { if (wins[i][j][k]) { myWin[k]++; }//如果玩家赢了，则弹出警告框显示 you win！ if (myWin[k] == 5) { alert(\"you win!\"); } }//调用ai算法 setTimeout(\"computerAI()\",5000); } 第九步：这是本程序最核心的部分–ai算法。 这里主要是运用了二维数组进行存储每个点上的危险指数，比如玩家在中心位置下了一颗棋子，那么ai就会对这个棋子周围一圈通过计算，加上相对应的值。例：图二，玩家为黑方，控制台中第六行第八列（经过反转处理）为黑子的落子点，周围对应的点加上了对应的值。 那么现在可以分两种ai，一种是进攻类，一种是防守类，两者的区别在于ai的分数和玩家的分数加的多少。 1.进攻类ai 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//ai 算法 function computerAI() { var myScore = []; var computerScore = []; var max = 0; var u = 0, v = 0; for (var i = 0; i &lt; 15; i++) { myScore[i] = []; computerScore[i] = []; for (var j = 0; j &lt; 15; j++) { myScore[i][j] = 0; computerScore[i][j] = 0; } } for (var i = 0; i &lt; 15; i++) { for (var j = 0; j &lt; 15; j++) {//for循环嵌套，遍历棋盘 if (chessBoard[i][j] == 0) { for (var k = 0; k &lt; count; k++) { if (wins[i][j][k]) { switch(myWin[k]) { case 1: myScore[i][j] += 10; break; case 2: myScore[i][j] += 200; break; //case 3和4只是增加的分数不同，略 }//ai加分大于myscore，故为攻击型，即case 1中加的分数&gt;10,略//判断落子点 if (myScore[i][j] &gt; max) {//先看防守 max = myScore[i][j]; u = i; v = j; } else if (myScore[i][j] == max) { if (computerScore[i][j]&gt;computerScore[u][v]){ u = i; v = j; } } //后看进攻（与防守类似，略 } } } } } 2.防守型： 防守型为myscore加分大于ai，故为防守型（代码大致相似，略） 第十步：画白色棋子，检查ai获胜（与玩家代码相似，略） 最终效果图： [作者简介] X3B0A1，女，北京市昌平区中山实验学校 主要研究方向：人工智能，c++、python、HTML5/JavaScript 123456789参考资料: [1]JavaScript - 人工智能 五子棋AI篇https://edu.csdn.net/course/detail/8660?[2]五子棋AI设计心得https://zhuanlan.zhihu.com/p/42811904[3]jS实现五子棋——AI篇https://www.jianshu.com/p/83fa8cc31a38[4]jS实现五子棋——UI篇https://www.jianshu.com/p/b178be0fbec3 欢迎各位大佬提出意见awa 本蒟蒻目前只会这样一种方法，有其他思路的欢迎提供嘿嘿。","link":"/2020/05/18/%E5%88%B6%E4%BD%9C%E4%BA%94%E5%AD%90%E6%A3%8Bai/"},{"title":"A+B problem 题解","text":"A + B problem 题解大家好,今天我来讲解一下A+B problem 首先我们来看一下题目描述： 输入两个整数 $a,b$ ，输出它们的和 ( $∣a∣,∣b∣≤10^9$ ) 嗯，这道题是一道我们小学一年级就会做的题，可是我们如何使用c++来实现呢？ 我们可以这样想： 先声明两个变量来存储输入的值，再输出这两个变量相加所得的和。 我们看到题目中说数据范围是 $10^9$ ，$int$ 型变量的范围是2的31次方，比题目的数据范围要大，因此我们可以使用整形数组来储存。 下面是这道题的代码： 123456789#include&lt;iostream&gt; //输入输出流所在的头文件using namespace std; //使用标准命名空间int main(){ //主函数入口 int a, b; //声明两个整形变量a和b cin &gt;&gt; a &gt;&gt; b; //输入a和b cout &lt;&lt; a + b; //输出a和b的和 return 0; //不要忘记返回0} end.","link":"/2020/05/18/A+B/"},{"title":"天津游记","text":"本文记录了我在5月17-19日三天，去天津办户口（玩耍）的事情，由于是在回家路上写的，没有联网，所以莫得图片个人的游记，我只是把一些事情记录一下，并没有用华丽的语言修饰，我个人也不是很喜欢这种“奢侈”的装饰。。。 day 171.5.0202 早上比较兴奋，5.50自己醒了，后来又睡着了，然后7点左右我妈把我叫醒。简单收拾收拾就出发了 一点也不堵车，到了之后先去了和平里搬箱子（搬家），顺便联系了一下网上认识的五中的一个学姐。吐槽一句：和平里那个房子真的是味道特大！！！ 然后去了香槟城，进去把包放下，准备去吃午饭 我忘了叫啥来着，吃的自助饺子，挺划算的，3个人90左右，饺子是厨师现包的，然后可以自己拿自己煮，还有好多小菜啥的（写到这儿我饿了QAQ） 然后吃完饺子去了武清图书馆，借了4本书，人挺少的，进馆要出示天津的健康码啥的，我们现弄，门口的保安很热心，也很有耐心，帮我们弄好。 然后去了区政府对面的公园，特别干净，花啊树啊都特别整齐，草（一种植物）也特别绿。 差不多逛一圈回家，某位上海初二大佬让我帮忙做了个html的大转盘，他们英语课用。 做完之后写了篇题解，然后打算研究一下搭建个人博客，于是过了一晚上，搭出了雏形。 最后11点多睡觉了，打的地铺，有一个单人折叠床但是不想睡，嘎吱嘎吱响。 Day 281.5.0202 早上7点多醒了，吃饭，上课（摸鱼）。上午把个人博客搭完了。（就是现在这个） 中午我爸妈出去买了好多吃的（凉皮啊凉面啊炸糕啊田螺啊凉菜啊包子啊等等等等）嗯都挺好吃的（滑稽） 下午上了节py爬虫课，爬了京东的商品，后来想爬淘宝发现有反爬虫，算了。。。 晚上在屋子里和我爸玩了会儿球，我妈在旁边边溜达，边听（唱）老歌。。。（笑） 后来就睡觉了 顺便说一下武清这边挺干净的，上午看到了路上洒水车，一条路走好几遍，每条街都特别干净，以及武清的路基本上都是方方正正的。 还有就是天津18号都开学了，我家楼下就是小学，然后昨天看他们上学，上操啥的挺有意思 武清这边学校真的多，说有七八十所都不夸张，基本上学校挨着学校，早上在楼上看楼下上学的人，就有4种校服 day 391.5.0202 早上8点才醒，慌慌忙忙一边上课一边吃饭，然后又试了试淘宝的爬虫，然而并没有什么*用。。。 后来准备回家，纠结了一会儿是在天津吃还是在北京吃，最后决定回家。 回家之前在楼下的一家超市（东西特便宜）买了点小零食（薯片啊面包啊还有一堆辣的肉啥的）（逐渐肥宅化），然后就开车回家喽 啊对了，路上路过杨村一中，我们开车绕着看了一圈，校园真大，环境也好，绿化也特别多…我好像还看见了里头的学生，加油考上杨一！ The end by X3B0A1. 2020.5.19","link":"/2020/05/19/%E5%A4%A9%E6%B4%A5%E2%80%9C%E6%B8%B8%E2%80%9D%E8%AE%B0/"},{"title":"动态规划复习笔记","text":"0.前言本蒟蒻学习完动态规划后仍然有些懵，于是就有了这篇复习笔记，希望可以通过这种方式使我掌握动态规划。 欢迎各位大佬挑错。 目录 动态规划的基本概念 什么是动态规划 动态转移方程 无后效性 最优子结构 动态规划解题步骤 动态规划的基本概念什么是动态规划？ 把一个大问题转换成若干个规模较小的同类型问题（子问题），当我们求出这些子问题的答案，大问题便可以求出。 在求解这些小问题的过程中，需要把重复计算的答案记录到数组中，如果遇到相同的小问题，便直接查询出结果。 我们来看一下官方的说法： 指把多阶段过程转化为一系列单阶段问题，利用各阶段之间的关系，逐个求解 其中，各阶段之间的关系，指的就是状态转移方程。那么状态转移方程是什么呢？其实就是大问题与子问题之间的关系。 举个例子：假如我们有1元、5元和11元的纸币若干张，怎样才能使用尽可能少的纸币凑15元呢？ 按照正常的思路，我们会尽可能的多拿面值大的： $11×1 + 1×4 = 15$ ，一共5张。 但是这是最优的吗？ 可以发现$3×5 = 15$ ，一共3张，按常规思路来，并不是最优的。 我们不妨倒推回去 : 凑成15，有三种情况： 取11： $11 + 4 = 15$ 取5： $5 + 10 = 15$ 取1： $1 + 14 = 15$ 以此类推，我们可以发现第二种，取5所需的纸币是最少的。 我们用$f(n)$来表示凑出n元所需的纸币数： 要想求$f(n)$，只需要知道 $f(n-1),f(n-5),f(n-11)$ 三者中的最小值，也就是： $f(n) = min[ f(n-1), f(n-5), f(n-11)] $这就是一个动态转移方程 还有一些其他的概念： 无后效性：要求出$f(15)$，只需要知道$f(14),f(10),f(4)$的值，而$f(14),f(10),f(4)$是如何算出来的，对之后的问题没有影响。将来的和之前的没有关系，就是无后效性 最优子结构：我们只要知道子问题$f(14)、f(10)、f(4)$的最优解，就可以得出大问题$f(15)$的最优解。 大问题的最优解可以由小问题的最优解推出 这种性质就叫“最优子结构性质”。 当一道题可以分成若干个子问题，并且满足无后效性和最优子结构时，我们就可以使用动态规划来做 2.动态规划的解题步骤： 把一个大问题分成几个小问题 求解小问题 从小问题中得到大问题的解","link":"/2020/05/18/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E2%80%94%E2%80%94%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"手动收藏一些有用的文章","text":"背包问题（一系列）动态规划rxzm↓语法 未完待续…by X3B0A1","link":"/2020/05/28/%E6%89%8B%E5%8A%A8%E6%94%B6%E8%97%8F%E4%B8%80%E4%BA%9B%E6%9C%89%E7%94%A8%E7%9A%84%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"project","slug":"project","link":"/tags/project/"},{"name":"problem","slug":"problem","link":"/tags/problem/"},{"name":"algorithm","slug":"algorithm","link":"/tags/algorithm/"},{"name":"daily life","slug":"daily-life","link":"/tags/daily-life/"},{"name":"favorites","slug":"favorites","link":"/tags/favorites/"}],"categories":[]}