{"pages":[],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2020/05/17/hello-world/"},{"title":"hello, Hexo!","text":"test1code here hello, Hexo!","link":"/2020/05/17/hello-Hexo/"},{"title":"制作五子棋AI","text":"关于本文：这是本蒟蒻的第一篇博客，介绍了我5升6暑假用一周时间做的作品 语言： Html5， JavaScript 成品：五子棋AI 正文：摘要:阿尔法狗对战柯洁围棋大赛很热门，那只是人工智能中的一个方向，展示了机器能代替人做某些事情。而围棋是很讲究智力的游戏，所以实现起来也是很难的，我用JS写了一个小程序——五子棋，五子棋相对来讲简单很多。 关键词：人工智能；网页编程；HTML5/JavaScript； 制作背景：现在，人工智能技术突飞猛进，许多职业已被机器取代，那么怎样用简单的算法实现五子棋ai呢？ 制作材料：电脑 设计思路： 棋盘的实现： 通过循环画直线 棋子的实现: 画出你想要的棋子，渐变填充颜色，封装成一个函数供调用。 落子的实现: 用数组存放每一个落子点，满足条件就落下对应的子 赢法数组: 用一个二维的数组记录五子棋的所有赢法。每种赢法都有一个值，值达到5就结束游戏。 确定计算机落子点: 这是难点，我们通过为某种赢法附一个权值，权值最大的就是落子价值最大的。 实现计算机落子: 通过上一步计算机找到了权值最大的落子坐标后，我们就可以实现落子了。 制作过程：第一步：写H5框架：1234567891011121314&lt;!doctype html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;Wu Zi Qi--AI&lt;/title&gt; &lt;style type=\"text/css\"&gt; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;script type=\"text/javascript\"&gt; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 第二步：本程序主要使用canvas检测鼠标点击返回值来进行落子,创建canvas对象： 12document.body.innerHTML = '&lt;canvas id=\"chess\" width=\"450\" height=\"450\"&gt; &lt;/canvas&gt;';var chess = document.getElementById('chess'); 第三步：创建赢法数组，统计数组等 123456//赢法数组,用来统计所有的赢法var wins = [];var count = 0;//赢法统计数组，用来统计var myWin = [];var computerWin = []; 第四步：创建并初始化数组显示棋盘 1234567var chessBoard = [];//数组显示棋盘 for (var i = 0; i &lt; 15; i++) { chessBoard[i] = []; for (var j = 0; j &lt; 15; j++) { chessBoard[i][j] = 0; } 第五步：画棋盘 123456789101112var context = chess.getContext('2d');//画棋盘 for (var i = 0; i &lt; 15; i++) { context.strokeStyle = '#00000';//设置颜色 context.beginPath(); context.moveTo(15, 15 + i * 30);//移动 context.lineTo(435, 15 + i * 30);//绘画 context.moveTo(15 + i * 30, 15);//移动 context.lineTo(15 + i * 30, 435);//绘画 context.stroke(); } 第六步：对赢法数组进行初始化和赋值 1234567891011//初始化赢法数组同初始化显示棋盘数组，省略 //横向 for (var i = 0; i &lt; 15; i++) { for (var j = 0; j &lt; 11; j++) { for (var k = 0; k &lt; 5; k++) { wins[i][j+k][count] = true; } count++; } }//纵向，左斜和右斜以此类推 第七步：初始化玩家和ai数组（略 第八步：画棋子，为了使棋子更加逼真，可以在棋子的脚上加一点渐变色，比如黑色棋子的右上角有白色渐变，从而模仿真实棋子反光（图一）。同时获取鼠标点击的位置，进行落子。 最后检查玩家获胜（即五子相连） 12345678910111213141516171819202122232425262728293031323334//画棋子 chess.onclick = function(e) {//鼠标点击容差再30以内（只要点击范围在以交叉点为中心的30*30的正方形状内，都算该交叉点） var i = Math.floor(e.offsetX / 30); var j = Math.floor(e.offsetY / 30); if (chessBoard[i][j] != 0) { return; } context.beginPath(); context.arc(15 + i * 30, 15 + j * 30, 13, 0, 2 * Math.PI); var grd = context.createRadialGradient(15 + i * 30, 15 + j * 30, 13, 15 + i * 30 + 2, 15 + j * 30 - 2, 0); grd.addColorStop(0, 'black'); grd.addColorStop(1, 'white'); context.fillStyle = grd; context.fill(); context.stroke(); chessBoard[i][j] = 1; //检查玩家获胜 for (var k = 0; k &lt; count; k++) { if (wins[i][j][k]) { myWin[k]++; }//如果玩家赢了，则弹出警告框显示 you win！ if (myWin[k] == 5) { alert(\"you win!\"); } }//调用ai算法 setTimeout(\"computerAI()\",5000); } 第九步：这是本程序最核心的部分–ai算法。 这里主要是运用了二维数组进行存储每个点上的危险指数，比如玩家在中心位置下了一颗棋子，那么ai就会对这个棋子周围一圈通过计算，加上相对应的值。例：图二，玩家为黑方，控制台中第六行第八列（经过反转处理）为黑子的落子点，周围对应的点加上了对应的值。 那么现在可以分两种ai，一种是进攻类，一种是防守类，两者的区别在于ai的分数和玩家的分数加的多少。 1.进攻类ai 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//ai 算法 function computerAI() { var myScore = []; var computerScore = []; var max = 0; var u = 0, v = 0; for (var i = 0; i &lt; 15; i++) { myScore[i] = []; computerScore[i] = []; for (var j = 0; j &lt; 15; j++) { myScore[i][j] = 0; computerScore[i][j] = 0; } } for (var i = 0; i &lt; 15; i++) { for (var j = 0; j &lt; 15; j++) {//for循环嵌套，遍历棋盘 if (chessBoard[i][j] == 0) { for (var k = 0; k &lt; count; k++) { if (wins[i][j][k]) { switch(myWin[k]) { case 1: myScore[i][j] += 10; break; case 2: myScore[i][j] += 200; break; //case 3和4只是增加的分数不同，略 }//ai加分大于myscore，故为攻击型，即case 1中加的分数&gt;10,略//判断落子点 if (myScore[i][j] &gt; max) {//先看防守 max = myScore[i][j]; u = i; v = j; } else if (myScore[i][j] == max) { if (computerScore[i][j]&gt;computerScore[u][v]){ u = i; v = j; } } //后看进攻（与防守类似，略 } } } } } 2.防守型： 防守型为myscore加分大于ai，故为防守型（代码大致相似，略） 第十步：画白色棋子，检查ai获胜（与玩家代码相似，略） 最终效果图： [作者简介] X3B0A1，女，北京市昌平区中山实验学校 主要研究方向：人工智能，c++、python、HTML5/JavaScript 123456789参考资料: [1]JavaScript - 人工智能 五子棋AI篇https://edu.csdn.net/course/detail/8660?[2]五子棋AI设计心得https://zhuanlan.zhihu.com/p/42811904[3]jS实现五子棋——AI篇https://www.jianshu.com/p/83fa8cc31a38[4]jS实现五子棋——UI篇https://www.jianshu.com/p/b178be0fbec3 欢迎各位大佬提出意见awa 本蒟蒻目前只会这样一种方法，有其他思路的欢迎提供嘿嘿。","link":"/2020/05/18/%E5%88%B6%E4%BD%9C%E4%BA%94%E5%AD%90%E6%A3%8Bai/"},{"title":"A+B problem 题解","text":"A + B problem 题解大家好,今天我来讲解一下A+B problem 首先我们来看一下题目描述： 输入两个整数 $a,b$ ，输出它们的和 ( $∣a∣,∣b∣≤10^9$ ) 嗯，这道题是一道我们小学一年级就会做的题，可是我们如何使用c++来实现呢？ 我们可以这样想： 先声明两个变量来存储输入的值，再输出这两个变量相加所得的和。 我们看到题目中说数据范围是 $10^9$ ，$int$ 型变量的范围是2的31次方，比题目的数据范围要大，因此我们可以使用整形数组来储存。 下面是这道题的代码： 123456789#include&lt;iostream&gt; //输入输出流所在的头文件using namespace std; //使用标准命名空间int main(){ //主函数入口 int a, b; //声明两个整形变量a和b cin &gt;&gt; a &gt;&gt; b; //输入a和b cout &lt;&lt; a + b; //输出a和b的和 return 0; //不要忘记返回0} end.","link":"/2020/05/18/A+B/"},{"title":"天津游记","text":"本文记录了我在5月17-19日三天，去天津办户口（玩耍）的事情，由于是在回家路上写的，没有联网，所以莫得图片个人的游记，我只是把一些事情记录一下，并没有用华丽的语言修饰，我个人也不是很喜欢这种“奢侈”的装饰。。。 day 171.5.0202 早上比较兴奋，5.50自己醒了，后来又睡着了，然后7点左右我妈把我叫醒。简单收拾收拾就出发了 一点也不堵车，到了之后先去了和平里搬箱子（搬家），顺便联系了一下网上认识的五中的一个学姐。吐槽一句：和平里那个房子真的是味道特大！！！ 然后去了香槟城，进去把包放下，准备去吃午饭 我忘了叫啥来着，吃的自助饺子，挺划算的，3个人90左右，饺子是厨师现包的，然后可以自己拿自己煮，还有好多小菜啥的（写到这儿我饿了QAQ） 然后吃完饺子去了武清图书馆，借了4本书，人挺少的，进馆要出示天津的健康码啥的，我们现弄，门口的保安很热心，也很有耐心，帮我们弄好。 然后去了区政府对面的公园，特别干净，花啊树啊都特别整齐，草（一种植物）也特别绿。 差不多逛一圈回家，某位上海初二大佬让我帮忙做了个html的大转盘，他们英语课用。 做完之后写了篇题解，然后打算研究一下搭建个人博客，于是过了一晚上，搭出了雏形。 最后11点多睡觉了，打的地铺，有一个单人折叠床但是不想睡，嘎吱嘎吱响。 Day 281.5.0202 早上7点多醒了，吃饭，上课（摸鱼）。上午把个人博客搭完了。（就是现在这个） 中午我爸妈出去买了好多吃的（凉皮啊凉面啊炸糕啊田螺啊凉菜啊包子啊等等等等）嗯都挺好吃的（滑稽） 下午上了节py爬虫课，爬了京东的商品，后来想爬淘宝发现有反爬虫，算了。。。 晚上在屋子里和我爸玩了会儿球，我妈在旁边边溜达，边听（唱）老歌。。。（笑） 后来就睡觉了 顺便说一下武清这边挺干净的，上午看到了路上洒水车，一条路走好几遍，每条街都特别干净，以及武清的路基本上都是方方正正的。 还有就是天津18号都开学了，我家楼下就是小学，然后昨天看他们上学，上操啥的挺有意思 武清这边学校真的多，说有七八十所都不夸张，基本上学校挨着学校，早上在楼上看楼下上学的人，就有4种校服 day 391.5.0202 早上8点才醒，慌慌忙忙一边上课一边吃饭，然后又试了试淘宝的爬虫，然而并没有什么*用。。。 后来准备回家，纠结了一会儿是在天津吃还是在北京吃，最后决定回家。 回家之前在楼下的一家超市（东西特便宜）买了点小零食（薯片啊面包啊还有一堆辣的肉啥的）（逐渐肥宅化），然后就开车回家喽 啊对了，路上路过杨村一中，我们开车绕着看了一圈，校园真大，环境也好，绿化也特别多…我好像还看见了里头的学生，加油考上杨一！ The end by X3B0A1. 2020.5.19","link":"/2020/05/19/%E5%A4%A9%E6%B4%A5%E2%80%9C%E6%B8%B8%E2%80%9D%E8%AE%B0/"},{"title":"动态规划复习笔记","text":"0.前言本蒟蒻学习完动态规划后仍然有些懵，于是就有了这篇复习笔记，希望可以通过这种方式使我掌握动态规划。 欢迎各位大佬挑错。 目录 动态规划的基本概念 什么是动态规划 动态转移方程 无后效性 最优子结构 动态规划解题步骤 动态规划的基本概念什么是动态规划？ 把一个大问题转换成若干个规模较小的同类型问题（子问题），当我们求出这些子问题的答案，大问题便可以求出。 在求解这些小问题的过程中，需要把重复计算的答案记录到数组中，如果遇到相同的小问题，便直接查询出结果。 我们来看一下官方的说法： 指把多阶段过程转化为一系列单阶段问题，利用各阶段之间的关系，逐个求解 其中，各阶段之间的关系，指的就是状态转移方程。那么状态转移方程是什么呢？其实就是大问题与子问题之间的关系。 举个例子：假如我们有1元、5元和11元的纸币若干张，怎样才能使用尽可能少的纸币凑15元呢？ 按照正常的思路，我们会尽可能的多拿面值大的： $11×1 + 1×4 = 15$ ，一共5张。 但是这是最优的吗？ 可以发现$3×5 = 15$ ，一共3张，按常规思路来，并不是最优的。 我们不妨倒推回去 : 凑成15，有三种情况： 取11： $11 + 4 = 15$ 取5： $5 + 10 = 15$ 取1： $1 + 14 = 15$ 以此类推，我们可以发现第二种，取5所需的纸币是最少的。 我们用$f(n)$来表示凑出n元所需的纸币数： 要想求$f(n)$，只需要知道 $f(n-1),f(n-5),f(n-11)$ 三者中的最小值，也就是： $f(n) = min[ f(n-1), f(n-5), f(n-11)] $这就是一个动态转移方程 还有一些其他的概念： 无后效性：要求出$f(15)$，只需要知道$f(14),f(10),f(4)$的值，而$f(14),f(10),f(4)$是如何算出来的，对之后的问题没有影响。将来的和之前的没有关系，就是无后效性 最优子结构：我们只要知道子问题$f(14)、f(10)、f(4)$的最优解，就可以得出大问题$f(15)$的最优解。 大问题的最优解可以由小问题的最优解推出 这种性质就叫“最优子结构性质”。 当一道题可以分成若干个子问题，并且满足无后效性和最优子结构时，我们就可以使用动态规划来做 2.动态规划的解题步骤： 把一个大问题分成几个小问题 求解小问题 从小问题中得到大问题的解","link":"/2020/05/18/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E2%80%94%E2%80%94%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"手动收藏一些有用的文章","text":"背包问题（一系列）动态规划rxzm↓语法 未完待续…by X3B0A1","link":"/2020/05/28/%E6%89%8B%E5%8A%A8%E6%94%B6%E8%97%8F%E4%B8%80%E4%BA%9B%E6%9C%89%E7%94%A8%E7%9A%84%E6%96%87%E7%AB%A0/"},{"title":"关于本博客","text":"本博客（x.blog）是X3B0A1借助hexo框架，icarus主题，花费了两天时间搭建出来的网站 由于贫穷，暂时不考虑购买服务器和域名 本博客尚未施工完毕，比如所头图还是icarus主题中的头像等等，另：近期发现图片炸掉了，等有时间了我会修理。 这个博客呢，主要是来记录生活、写题解、写笔记等等，并不是纯学术的博客，也不是纯休闲。平时会把一些感想啊游记啊烦恼啊等等记录进来，也会把平时学习的oi或者开发有关的知识甚至是文化课的东西记录进来。 总之就是杂七杂八的东西，如果想单纯的看一个，可以在归档里查看。 左思右想觉得没什么可说的了qaq好了就到这儿了the end.by X3B0A12020-05-29","link":"/2020/05/29/about%20this%20blog/"},{"title":"20200530蓝桥杯选拔赛游记&amp;&amp;赛后总结&amp;&amp;上半年oi学习反思","text":"5月30日参加了蓝桥杯初级组北京市的省级选拔赛，特此记录1 报名学校计算机老师来找我，嗯我觉得反正这段时间也没参加过啥大比赛，于是简单问了问题目难度啥的就报了， 300块钱没了QAQ 2 赛前准备由于一直是线上学习，然后呢刚开始（五月初）学了一些动规和图论，然后也没怎么刷题，一直是处于摸鱼的状态中。然后五月中旬刷了几道水题，五月下旬就在疯狂的补作业，所以一直没怎么准备。 （身边好几个朋友说：“你特么个班长，起到了良好的带头作用【滑稽】”） 3 意外事件有那么几天我甚至忘记了我还有个比赛，然后比赛前一天幸亏老师提醒上去测试一下，才发现老师没发给我准考证awa 发现是周六13.30到15.30，和别的课冲突了，于是去调课。 4 赛前90分钟12点10分才下上午的课，然后10分钟吃饭，10分钟翻出家里头一个三脚架，因为比赛时需要从后方45°拍摄视频，要求露出上半身和双手，用腾讯会议监控www 然后12.30多入场（就是入会）经过了20来分钟的角度调试和电脑登陆啊乱七八糟的东西，终于准备好了 然后还有半个小时，我打算复习一下（没错还剩半个小时我才想起来复习2333）然后自己也没有完整的笔记，就上网上搜，也没啥，于是找到了自己以前教一个同学列的一个表，顺着复习一下 123456789101112131415161718192021222324252627282930313233341. 输出2. 变量 2.1 基本数据类型 2.2 数据类型转化 2.2.1 自动类型转换 2.2.2 强制类型转换 2.3 运算3. 输入4. if语句 4.1 逻辑运算符 4.2 if语句 4.2.1 if语句 4.2.2 if...else语句 4.2.3 if...else if...else if... ... ... else语句5. 循环 5.1 while循环 5.1.1 while循环 5.1.2 do-while循环 5.2 for循环 5.2.1 单层循环 5.2.2 嵌套循环6. 文件操作7. 一维数组 7.1 数组 7.2 有关数组的函数8.二维数组9.字符串 9.1 字符数组 9.2 字符串10. c风格输入输出11. 结构体12. 函数13. 递归14. 递推 真的很简单，我觉得初级组应该也就会考这些了。。。 要是考算法我就凉凉了 数据结构和指针应该不会考 毕竟是初级组然后字符串一直是我不擅长的，于是就又复习了一下以前的代码，贴在下面： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main(){ //直接使用cin //不可带空格 /* string str; cin&gt;&gt;str; cout&lt;&lt;str; */ //若要带空格，使用 //getline（cin，变量名 ） /* string str; getline(cin,str); cout&lt;&lt;str; */ //字符串长度 变量名.size(); /* string a = \"computer\"; cout&lt;&lt;a.size(); */ //查找 //被查找的变量.find(查找的变量); /* string str0 = \"abcbcbc\"; string str1 = \"bc\"; string str2 = \"xy\"; int pos = str0.find(str1); cout&lt;&lt;pos&lt;&lt;endl; pos = str0.find(str2); if(pos == string::npos){ cout&lt;&lt;\"yes\"; } */ //替换 字符串变量名.relpace(替换的启示下标，被替换的长度，替换的字符串); /* string str0 = \"abcbcw\"; string str1 = \"xy\"; // a bcbc-&gt;xy w str0.replace(1,4,str1); // a xy w cout&lt;&lt;str0; */ //截取 //字符串变量名.substr(截取的起始下标，截取长度); return 0;} 好像文件丢了一些，不管怎么着能复习一点就行 然后怕卡时间，又看了一下c的输入输出（printf 和 scanf） 然后就开始考试了awa 5 赛时五道选择题，4道编程题， 选择先做选择题：好像不难，但是由于我还没有准备oi的初赛，所以好多基础知识做不上来QAQ 我列举三道我还记得的题吧 90-100的素数有几个 A 0 B 1 C 2 D 3 众所周知，90-100中只有一个97是质数 然后。。。我居然一时脑子抽，把91误认为质数了。。。 囧 不过没关系 还有一道是进制转换 让在几个不同进制的数里头选一个最小的 八进制的我转过来了（从左往右第一位位数乘8再加上第二位）十六进制的转过来了（方法同八） 十进制不用转 以上都是侥幸的出现的两位数 然后有一个二进制101000 囧 我不会转了 但是我会把10进制转2进制 然后从上面那三个里头的最小的，转成2进制： 101010 great 101010 &gt; 101000 所以做出来了。。真侥幸啊。。。 还有一个关于ip地址的 幸亏以前有了解一点点网络安全方面的知识 总之还是挺幸运的。 编程一共四道题，一一说一下： 第一题： 输入一个分数，大于等于90，输出A，大于等于80输出B，大于等于70输出C，70以下输出D 真简单，几个if就行 二话不说上代码： 12345678910111213141516#include&lt;iostream&gt;using namespace std;int n;int main () { cin &gt;&gt; n; if(n &gt;= 90){ cout &lt;&lt; \"A\"; }else if(n &gt;= 80){ cout &lt;&lt; \"B\"; }else if(n &gt;= 70){ cout &lt;&lt; \"C\"; }else{ cout &lt;&lt; \"D\"; } return 0;} 由于赛时全程录屏+后台检测，所以不敢复制题目下来，凭记忆打出来的，别追求严谨性了，能看懂就行 第二题 输入一个高度，一个铁球从这个高度下降，每弹一次，高度减少一半，第10次弹起后离地的高度和铁球走过的距离（不包括第十次落下的距离） 嗯不是很难，稍微分析一下即可 然后我在这道题上居然卡了10分钟？！ 题太水，不想过度讲解www 原始代码：是错的 123456789101112131415161718#include&lt;iostream&gt;using namespace std;int n;int main () { cin &gt;&gt; n; double m, ms = n; for( int i = 0; i &lt; 8; i++ ){ n /=2; ms += 2*n; } m = n; ms += n; cout &lt;&lt; m &lt;&lt; endl; cout &lt;&lt; ms; return 0;} 修改后： 12345678910111213141516171819#include&lt;iostream&gt;using namespace std;int n;int main () { cin &gt;&gt; n; double m, ms = n; for( int i = 0; i &lt; 9; i++ ){ n /= 2; ms += 2*n; } m = n/2; ms += n/2; cout &lt;&lt; m &lt;&lt; endl; cout &lt;&lt; ms; return 0;} 另外写了个生成数据和检测答案的程序（俗称对拍）： 12345678910111213#include&lt;iostream&gt;using namespace std;int n;int main () { cin&gt;&gt;n; int ans = n; for(int i=0;i&lt;10;i++){ n*=2; ans += n; } cout&lt;&lt;n&lt;&lt;ans; return 0;} 于是愉快的ac喽 第三题： 输入10个数，输出他们的最大值，最小值，平均值，用逗号分割 太过简单了，不上代码了。。。 其实是文件丢了，不想再写了 第四题：这个真的是。。。先看题吧 输入一个数，输出这个数以内的所有回文数 看着很简单 我记得半年前在洛谷上做过类似的www 先不管洛谷上的，先说说我是怎么做的 首先尝试了常规做法。。。不行 用string。。。不行 我太菜了 于是打算暴力打表 毕竟 暴力出奇迹 然后简单打了个表： 12345678910111213#include&lt;iostream&gt;using namespace std;int n = 10;int main () { for( int i=1;i&lt;n;i++){ for(int j=0;j&lt;n;j++){ for(int k=0;k&lt;n;k++){ cout&lt;&lt;i&lt;&lt;j&lt;&lt;k&lt;&lt;k&lt;&lt;j&lt;&lt;i&lt;&lt;\",\"; } } } return 0;} 123456789101112131415#include&lt;iostream&gt;using namespace std;int n = 10;int main () { for( int i=0;i&lt;n;i++){ for(int j=0;j&lt;n;j++){ for(int k=0;k&lt;n;k++){ for(int q=0;q&lt;n;q++){ cout&lt;&lt;i&lt;&lt;j&lt;&lt;k&lt;&lt;q&lt;&lt;k&lt;&lt;j&lt;&lt;i&lt;&lt;endl; } } } } return 0;} 成果：大量数字来袭 12int aaa[10000000] = {1,2,3,4,5,6,7,8,9,11,22,33,44,55,66,77,88,99,101,111,121,131,141,151,161,171,181,191,202,212,222,232,242,252,262,272,282,292,303,313,323,333,343,353,363,373,383,393,404,414,424,434,444,454,464,474,484,494,505,515,525,535,545,555,565,575,585,595,606,616,626,636,646,656,666,676,686,696,707,717,727,737,747,757,767,777,787,797,808,818,828,838,848,858,868,878,888,898,909,919,929,939,949,959,969,979,989,999,1001,1111,1221,1331,1441,1551,1661,1771,1881,1991,2002,2112,2222,2332,2442,2552,2662,2772,2882,2992,3003,3113,3223,3333,3443,3553,3663,3773,3883,3993,4004,4114,4224,4334,4444,4554,4664,4774,4884,4994,5005,5115,5225,5335,5445,5555,5665,5775,5885,5995,6006,6116,6226,6336,6446,6556,6666,6776,6886,6996,7007,7117,7227,7337,7447,7557,7667,7777,7887,7997,8008,8118,8228,8338,8448,8558,8668,8778,8888,8998,9009,9119,9229,9339,9449,9559,9669,9779,9889,9999,..............................省略大量数字,900009,901109,902209,903309,904409,905509,906609,907709,908809,909909,910019,911119,912219,913319,914419,915519,916619,917719,918819,919919,920029,921129,922229,923329,924429,925529,926629,927729,928829,929929,930039,931139,932239,933339,934439,935539,936639,937739,938839,939939,940049,941149,942249,943349,944449,945549,946649,947749,948849,949949,950059,951159,952259,953359,954459,955559,956659,957759,958859,959959,960069,961169,962269,963369,964469,965569,966669,967769,968869,969969,970079,971179,972279,973379,974479,975579,976679,977779,978879,979979,980089,981189,982289,983389,984489,985589,986689,987789,988889,989989,990099,991199,992299,993399,994499,995599,996699,997799,998899,999999}; 然后后边的代码： 12345678910111213141516171819#include&lt;iostream&gt;using namespace std;//这里是上面的大打表数组int main () { int n, sum = 0; cin &gt;&gt; n; for(int i = 0; i &lt; n; i++){ if(aaa[i+1] &gt; n){ cout&lt;&lt;aaa[i]&lt;&lt;endl; sum++; break; } cout&lt;&lt;aaa[i]&lt;&lt;endl; sum++; } cout&lt;&lt;\"*\"&lt;&lt;sum; return 0;} 也不给个数据范围，差评 然后这题就ac了 赛后好奇的看了我洛谷以前的提交记录 嗯之前那道题是回文质数，就是在回文的基础上还是质数 历史分数：100 www惊恐 继续看提交记录 一次ac？ 看一下提交记录的代码 额 又是打表 看来当时是抄的题解啊。。。 好吧。。。 第四题正常解发代码写出来后我会写博客的。 然后这个时候才过了一个小时 呆着也是待着，不如提交了 然后就交卷了 6 赛后总结整体来说还算可以的，但是质数的题错的很。。。然后进制转换也是很侥幸的答对了。。最后一题暴力也是不应该的。。 总结几点： 基础不牢固 以前没有记笔记写博客 做题时没有深度的思考 7 2020上半年oi学习反思其实这半年感觉效率很低， 一月份学校期末，加上一直在天津上课，并没有学多少。 二月份在家上天津小升初的课，写作业，摸鱼，氵氵氵，学校网课，但是也学习了一些（从文件的修改日期来看，二月份我学习了高精度） 三月份学校的网课加上天津的课，其实本来没多少作业，但是效率低加上一直在摸鱼，于是没学多少。从文件修改日期看，三月下旬我学习了动态规划中的01背包等等。三月初刷了一些水题，共15道，但是题很水 同样，从修改日期看， 二三月份我收集了很多娱乐程序。。看来当时经常水群 四月份还算可以，主要是因为我老师开直播课了，然后四月学了贪心，虽然说质量不咋地，但是至少学了。 五月份，五一期间还是可以的，上了洛谷的课，然后也有做题，有复习dp，贪心啥的，也有学习图论，但是并没有什么进展。五月份开始写博客了，然后搭建了自己的博客，学会了一点点python爬虫，收获还算可以，但是也不可观。 总之这段时间并没有学多少，也没有刷题，在网上聊天水群水本本水知乎花费的时间太多了，从六一开始需要改正。。。 8 规划之后就先把动规贪心模拟弄扎实了，然后刷一些题，然后看距离初赛的时间决定是接着学图和搜索，还是先准备初赛 然后初赛准备过后就开始复习，刷题了。 嗯基本就是这样 哇这篇博客源码我居然写了将近500行 好了好了就到这儿了 附：qq号：3242954996愿意带我的大佬可以加我鸭蒟蒻也可以和我一起学习awa the end.by X3B0A12020.5.30","link":"/2020/05/30/20200530%E8%93%9D%E6%A1%A5%E6%9D%AF%E9%80%89%E6%8B%94%E6%B8%B8%E8%AE%B0/"},{"title":"数论笔记","text":"1 整除 尾数系： 2,5 ; 4,25 ; 8,125 ; 16,625 数位和： 3 , 9 数段和： 99, 999, 9999, ……(衍生：33，333… ; 11, 111….) 数位差： 11 数段差： 7, 11, 13, 1001, 77, 91, 143（三位一段） 方法： 拆分 72 = 8×9； 15 = 3×5 逐一满足 2 “五数” 质数合数 100 以内（略） 特殊质数： “2” 唯一偶质数 “5” 唯一末位为5的质数 分解质因数： 因数倍数 求（）和[]短除法 短除模型（不知道为什么不能用LaTeX，就插图片吧） the end.by X3B0A12020-05-30","link":"/2020/05/30/%E5%B0%8F%E5%8D%87%E5%88%9D%E6%95%B0%E8%AE%BA%E7%AC%94%E8%AE%B0/"},{"title":"午后感叹","text":"唉，20200614，开学两周之后，bj的疫情又开始上涨了，而且在新发地！！！会不会封城啊，要不要不管毕业考，直接去天津啊。。。怎么搬家啊。。。 $QAQ$","link":"/2020/06/14/%E5%8D%88%E5%90%8E%E6%84%9F%E5%8F%B9/"}],"tags":[{"name":"project","slug":"project","link":"/tags/project/"},{"name":"problem","slug":"problem","link":"/tags/problem/"},{"name":"algorithm","slug":"algorithm","link":"/tags/algorithm/"},{"name":"daily life","slug":"daily-life","link":"/tags/daily-life/"},{"name":"favorites","slug":"favorites","link":"/tags/favorites/"},{"name":"about","slug":"about","link":"/tags/about/"},{"name":"游记","slug":"游记","link":"/tags/%E6%B8%B8%E8%AE%B0/"},{"name":"math","slug":"math","link":"/tags/math/"}],"categories":[]}